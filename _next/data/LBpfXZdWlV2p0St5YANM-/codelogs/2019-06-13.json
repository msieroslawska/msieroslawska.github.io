{"pageProps":{"codelog":{"tags":["javascript","oop"],"title":"2019-06-13","content":"<h2>Plan for the day</h2>\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled> Continue watching <a href=\"https://frontendmasters.com/courses/javascript-hard-parts/\">JavaScript: The Hard Parts</a> by Will Sentance</li>\n</ul>\n<h2>Learned today</h2>\n<h3>OOP</h3>\n<p>Is a popular paradigm to structure the code, which:</p>\n<ul>\n<li>makes it easy to add new features and functonalities (we don't have to rewrite stuff to add new features),</li>\n<li>is efficient in terms of memory,</li>\n<li>as a clear structure (easy for the author and othe developers).</li>\n</ul>\n<p>If we are operating on some data and there are functionalities we'd like to apply to it, a nice and logical solution would be to store data and methods together in an object (<strong>encapsulate</strong>):</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">let</span> user1 = {\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'Will'</span>,\n  <span class=\"hljs-attr\">score</span>: <span class=\"hljs-number\">6</span>,\n  <span class=\"hljs-attr\">increment</span>: <span class=\"hljs-function\">() =></span> {\n    user1.score++;\n  },\n};</code></pre>\n<p>There are other ways to declare objects:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">let</span> user2 = {};\nuser2.name = <span class=\"hljs-string\">'Jim'</span>;\nuser2.score = <span class=\"hljs-number\">10</span>;\nuser2.increment = <span class=\"hljs-function\">() =></span> {\n  user2.score++;\n};</code></pre>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">let</span> user3 = <span class=\"hljs-built_in\">Object</span>.create(<span class=\"hljs-literal\">null</span>);\nuser3.name = <span class=\"hljs-string\">'Jess'</span>;\nuser3.score = <span class=\"hljs-number\">2</span>;\nuser3.increment = <span class=\"hljs-function\">() =></span> {\n  user3.score++;\n};</code></pre>\n<h4>How do we avoid repeating ourselves?</h4>\n<ol>\n<li>Wrap in a function</li>\n</ol>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">userCreator</span>(<span class=\"hljs-params\">name, score</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> user = {};\n  user.name = name;\n  user.score = score;\n  user.increment = <span class=\"hljs-function\">() =></span> {\n    user.score++;\n  };\n  <span class=\"hljs-keyword\">return</span> user;\n}\n\n<span class=\"hljs-keyword\">let</span> user1 = userCreator(<span class=\"hljs-string\">'Will'</span>, <span class=\"hljs-number\">6</span>);\n<span class=\"hljs-keyword\">let</span> user2 = userCreator(<span class=\"hljs-string\">'Jess'</span>, <span class=\"hljs-number\">2</span>);\nuser1.increment();</code></pre>\n<p>This approach has a fundamental flaw: what if we create 1000 users, and <code>userCreator</code> has 100 of different functions? Each of 1000 users would be a brand new object with new, separate function definitions. Do we need to allocate all that memory?</p>\n<ol start=\"2\">\n<li>Use the prototypal nature of JS: when a method is not found in the object, JS looks for it in next object in the prototype chain. In this solution we are storing the common items (functions) in a separate store which we use to populate <code>userCreator</code>:</li>\n</ol>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">userCreator</span>(<span class=\"hljs-params\">name, score</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> user = <span class=\"hljs-built_in\">Object</span>.create(userFunctionStore);\n  user.name = name;\n  user.score = score;\n  <span class=\"hljs-keyword\">return</span> user;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">userFunctionStore</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-attr\">increment</span>: <span class=\"hljs-function\">() =></span> { <span class=\"hljs-built_in\">this</span>.score++; },\n  <span class=\"hljs-attr\">login</span>: <span class=\"hljs-function\">() =></span> { <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'You\\'re logged in!'</span>); },\n}\n\n<span class=\"hljs-keyword\">let</span> user1 = userCreator(<span class=\"hljs-string\">'Will'</span>, <span class=\"hljs-number\">6</span>);\nuser1.increment();</code></pre>\n<p><code>Object.create()</code> always returns an empty object. What is being passed as an argument is being stored as a reference in <code>user</code>'s <code>__proto__</code> property (creating a <strong>prototype chain bond</strong> ). What is being stored in <code>user1</code> (what is returned from <code>userCreator()</code>) does <strong>not</strong> have <code>increment()</code> and <code>login()</code>.</p>\n<h2>Resources list</h2>\n<h2>Other resources</h2>\n"}},"__N_SSG":true}